

{% extends "core/base.html" %}
{% load bootstrap3 %}

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy" crossorigin="anonymous"></script>

{% bootstrap_css %}
{% bootstrap_javascript %}

{% block header %}


<noscript>
  <div class="disabled">Javascript is disabled in your web browser. Please enable JavaScript to view the chart.</div>
</noscript>
  
<style>
  
  #video_box{
      position:relative;
  }
  
  #video_overlays {
      position:absolute;
      z-index:300000;
      text-align:center;
  }
  
  .responsive {
    width: 100%;
    height: auto;
  }

  .box {
    border: 7px solid #585858;
    background-color: #D3D3D3;
    border-radius: 10px;
    padding: 10px;
    align-items: center;
    text-align: center;
  }
  
  .box2 {
    border: 7px solid #585858;
    border-radius: 10px;
    padding: 10px;
    align-items: center;
    text-align: center;
  }
  
  .box_inner {
    background-color: #E8E8E8;
    font-size: xx-large;
    color: #000;
  }
  
  .headers{
    color: #585858;
  
  }

  .settings-menu {
    background-color: #E8E8E8; 
  }
 
  h1{
    color:#585858; 
    font-weight: bold;
  }

</style>


<h1>GaugeView</h1>


{% endblock header %}

{% block content %}


<div class="row">
  <div class="col-md-8">
    <div id="wrap_video" class="box">
      <div class="responsive" id="video_box">
        <div id="video_overlays" class="responsive">
    	     <canvas id="video-canvas" class="responsive"></canvas>
        </div>
        <div>
          <video id="player" controls autoplay class="responsive"></video>
        </div>
      </div>
    </div>
  </div>


  <div class="col-md-4" style="align-items: center">
  
    <div class="box">
      <div class="box_inner">
        <div class="headers">time</div>
        <div id="time_box"></div>
      </div>
      <p>
      <div class="box_inner">
        <div class="headers">pressure</div>
        <div id="psig_box"></div>
      </div>
      <p>

      <div>
        <button class="btn btn-default" id="reset">Reset</button>
        <button class="btn btn-default" id="export">Export</button><br><p>

          <form action="{% url 'core:gauge_export' %}" method='post'>
            {% csrf_token %}
            <input name="json" id="json" type="hidden" value="">
            <button class="btn btn-primary" id="export_download_button" style="display: none;" name="submit" onclick='removeButton(this)'>DOWNLOAD CSV</button>
          </form>
      </div>
    </div>
    <p><br>

    <div class="box">
      <div id="settings-menu" class="settings-menu" style="display: none;">

        <canvas id="settings-canvas" width=100 height=100></canvas>
        <p>

        <div class="row" style="padding-left:20px; text-align: left">
          <div class="col-xs-6">
              Sensitivity:<br><input id="sensitivity_field" size="5"><br>
              Radius factor:<br><input id="r_factor_field" size="5"><br>
              Sm. radius factor:<br><input id="sm_r_factor_field" size="5"><br>
              Min. pixels:<br><input id="pxls_detected_min_field" size="5"><br>
            </div>
            <div class="col-xs-6">
              R&sup2; min:<br><input id="r_sq_min_field" size="5"><br>
              Residual cutoff:<br><input id="residual_cutoff_field" size="5"><br>
              Ref. angle:<br><input id="ref_angle_field" size="5"><br>
              Calibration:<br><input id="calib_field" size="5"><br>
            </div>
            <p><br>

        </div>
        <p><br>
        <button class="btn btn-primary" onclick="updateParams()">Update</button>
        <p><br>
      </div>

      <button class="btn btn-default" onclick="toggleSettingsVisibility()">Settings</button>
    </div>

    <span id="messages"></span>
  </div>
  <div id="text"></div>

</div>


<p><br>
<div class="box2" id="dynamic_chart">
  <canvas style="background-color: #ffffff" id="chart" width=100 height=50></canvas>
</div>
<p><br>




<script>

const message = elem('messages');
const settingsMenu = elem('settings-menu');
const player = elem('player');
const settingsCanvas = elem('settings-canvas');
const settingsCtx = settingsCanvas.getContext('2d');
const resetButton = elem('reset');
const exportButton = elem('export');
const videoCanvas = elem('video-canvas');
const videoCtx = videoCanvas.getContext('2d');

		
var params = {
  sensitivity : {{ sensitivity }},
  r_factor : {{ r_factor }},
  sm_r_factor : {{ sm_r_factor }},
  pxls_detected_min : {{ pxls_detected_min }},
  r_sq_min : {{ r_sq_min }},
  residual_cutoff : {{ residual_cutoff }},
  ref_angle : {{ ref_angle }},
  calib : {{ calib }},
}

var gauge = {
  centerX: null,
  centerY: null,
  radius: null,
  xUnit: 0,   // unit circle x value, denotes needle position
  yUnit: 0,   // unit circle y value, denotes needle position
}

var detectedPixels = {
  pointsX: null,
  pointsY: null
}


var videoParams = {
  videoWidth: null,
  videoHeight: null,
  x0: null,
  y0: null, 
}


var time = (function() {
  var timeElapsed = 0;
  const read = () => {
    return timeElapsed;
  }
  const increase = () => {
    timeElapsed += 1;
    return timeElapsed;
  }
  const reset = () => {
    timeElapsed = 0;
  }
  return {read: read, increase: increase, reset: reset}
}());



var psig = (function() {
  var pressure = 0;
  const read = () => {
    return pressure;
  }
  const write = (val) => {
    pressure = val;
  }
  return {read: read, write: write}
}());



var isMobile = navigator.userAgent.match(/(iPad)|(iPhone)|(iPod)|(android)|(webOS)/i)
var constraints;
if (isMobile) {
  constraints = { video: {facingMode: {exact: "environment"}}};
}
else {
  constraints = {video: true};
}



// Get video stream
navigator.mediaDevices.getUserMedia(constraints)
.then(function(stream) {
      player.srcObject = stream;
      player.onloadedmetadata = function(e) {
        player.play();
        prepareCamView();
      };
})
.catch(function(err) {
  console.log("Exception:", err)
});

displayParams();




setInterval(function(){
  pressureChart.data.datasets[0]["data"].push({"x": time.read(), "y": psig.read()});
  pressureChart.update();
  updateMetrics();
  displayCamInsideSettings();

	$.ajax({
    headers: { "X-CSRFToken": "{{csrf_token}}"},
    url:"{% url 'core:read_gauge' %}",
    method:"POST",
    data:{
      image_string: convertCanvasToBase64(settingsCanvas),
      radius: gauge.radius,
      comp_ratio: videoCanvas.height/settingsCanvas.height,
      params: JSON.stringify(params)    
    },
    success:function(response) {
      /* draw pixels in settings menu */
      detectedPixels.pointsX = JSON.parse(response.points_x);
      detectedPixels.pointsY = JSON.parse(response.points_y);
      drawDetectedPixels();
      //drawCirclesInSettings();

      /* get pressure and needle position */
			if ((response.psig !== 999) && (response.x_unit !== 999) && (response.y_unit !== 999)) {
				psig.write(response.psig);
        gauge.xUnit = response.x_unit;
        gauge.yUnit = response.y_unit;
        clearCanvas();
        drawGaugeAndNeedle();
      }
    },
    error:function(){
      console.log("Ajax Exception")
    }
  });
  time.increase();
}, 1000) /* time in milliseconds */





resetButton.addEventListener('click', () => {
	time.reset();
  resetPressureChart();
});


function convertCanvasToBase64(canvas){
  return canvas.toDataURL("image/png").replace(/^data:image\/(png|jpg);base64,/, '');
}

function clearCanvas(){
  // clear the canvas so we can draw a fresh gauge and needle at new position
  videoCtx.clearRect(0, 0, videoCanvas.width, videoCanvas.height);
}

function drawGaugeAndNeedle(){
  videoCtx.beginPath();
  videoCtx.moveTo(gauge.centerX, gauge.centerY);
  videoCtx.lineTo(gauge.centerX + (gauge.xUnit*gauge.radius), gauge.centerY+(gauge.yUnit*gauge.radius));
  videoCtx.lineWidth = 4;
  videoCtx.strokeStyle = '#0000ff';
  videoCtx.stroke();
  drawCircles();
}


function updateMetrics(){
	elem("time_box").innerText = `${time.read()} s`;
  elem("psig_box").innerText = `${psig.read()} psig`;
}

function displayCamInsideSettings(){
  settingsCtx.drawImage(player, videoParams.x0, videoParams.y0, gauge.radius*2, gauge.radius*2, 0, 0, settingsCanvas.width, settingsCanvas.height);
}

function isStreamSupported() {
  return navigator.getUserMedia
}

exportButton.addEventListener('click', () => {
	elem('json').value=JSON.stringify(pressureChart.data.datasets[0]["data"])
	elem('export_download_button').style="display: true;"
});


function toggleSettingsVisibility(){
  toggleVisibility(settingsMenu);
}

function toggleVisibility(element){
  if (element.style.display == "none"){
    element.style.display = "block";
  } else {
    element.style.display = "none";
  }
}

function removeButton(button) {
   button.style="display: none;"
}



function prepareCamView(){
  // get video stream dimensions
  videoParams.videoWidth = player.srcObject.getTracks()[0].getSettings().width
  videoParams.videoHeight = player.srcObject.getTracks()[0].getSettings().height
  // setup canvas for drawing circles
  videoCanvas.width = videoParams.videoWidth;
  videoCanvas.height = videoParams.videoHeight;
  gauge.centerX = videoCanvas.width / 2;
  gauge.centerY = videoCanvas.height / 2;
	//cut out a square image from webcam stream
	if (videoCanvas.height <= videoCanvas.width){
		gauge.radius = (videoCanvas.height*0.8)/2;
		videoParams.y0 = videoCanvas.height*0.1;
		videoParams.x0 = (videoCanvas.width-(2*gauge.radius))/2;
	}
	else {
		gauge.radius = (videoCanvas.width*0.8)/2;
		videoParams.y0 = (videoCanvas.height-(2*gauge.radius))/2;
		videoParams.x0 = videoCanvas.width*0.1;
	}
}

function drawCircles (){
      videoCtx.beginPath();
      videoCtx.arc(gauge.centerX, gauge.centerY, gauge.radius, 0, 2 * Math.PI, false);
      videoCtx.lineWidth = 2;
      videoCtx.strokeStyle = '#ff0000';
      videoCtx.stroke();
      videoCtx.beginPath();
      videoCtx.arc(gauge.centerX, gauge.centerY, gauge.radius/20, 0, 2 * Math.PI, false);
      videoCtx.lineWidth = 2;
      //videoCtx.fillStyle = '#ff0000';
      //videoCtx.fill();
      videoCtx.strokeStyle = '#ff0000';
      videoCtx.stroke();
}

function drawDetectedPixels(){
  settingsCtx.beginPath();
  for (let i = 0; i < detectedPixels.pointsX.length; i++) {
    settingsCtx.fillRect(detectedPixels.pointsX[i], detectedPixels.pointsY[i],5,5); 
  }
  settingsCtx.stroke();
}

function drawCirclesInSettings(){
  settingsCtx.beginPath();
  settingsCtx.arc(settingsCanvas.width/2, settingsCanvas.height/2, gauge.radius*settingsCanvas.height/videoCanvas.height*r_factor, 0, 2 * Math.PI, false);
  settingsCtx.lineWidth = 1;
  settingsCtx.strokeStyle = '#0000ff';
  settingsCtx.stroke();
  settingsCtx.beginPath();
  settingsCtx.arc(settingsCanvas.width/2, settingsCanvas.height/2, gauge.radius*settingsCanvas.height/videoCanvas.height*sm_r_factor, 0, 2 * Math.PI, false);
  settingsCtx.lineWidth = 1;
  settingsCtx.strokeStyle = '#0000ff';
  settingsCtx.stroke();
}

$(window).resize(function(e) {
  prepareCamView();
});

function displayParams(){
  elem("sensitivity_field").value = params.sensitivity;
  elem("r_factor_field").value = params.r_factor;
  elem("sm_r_factor_field").value = params.sm_r_factor;
  elem("pxls_detected_min_field").value = params.pxls_detected_min;
  elem("r_sq_min_field").value = params.r_sq_min;
  elem("residual_cutoff_field").value = params.residual_cutoff;
  elem("ref_angle_field").value = params.ref_angle;
  elem("calib_field").value = params.calib;
}

function updateParams(){
  sensitivity_value = elem("sensitivity_field").value;
  r_factor_value = elem("r_factor_field").value;
  sm_r_factor_value = elem("sm_r_factor_field").value;
  pxls_detected_min_value = elem("pxls_detected_min_field").value;
  r_sq_min_value = elem("r_sq_min_field").value;
  residual_cutoff_value = elem("residual_cutoff_field").value;
  ref_angle_value = elem("ref_angle_field").value;
  calib_value = elem("calib_field").value;

  // Sensitivity must be between 0 and 255
  if ((!isNaN(sensitivity_value)) && (sensitivity_value >= 0) && (sensitivity_value <= 255)){
    params.sensitivity = sensitivity_value;
  }
  if (!isNaN(sm_r_factor_value)){
    params.sm_r_factor = sm_r_factor_value;
  }
  // R_sq coefficient must be between 0 and 1
  if ((!isNaN(r_sq_min_value)) && (r_sq_min_value >= 0) && (r_sq_min_value <= 1)){
    params.r_sq_min = r_sq_min_value;
  }
  if ((!isNaN(ref_angle_value)) && (ref_angle_value > 0)){
    params.ref_angle = ref_angle_value;
  }
  if ((!isNaN(calib_value)) && (calib_value > 0)){
    params.calib = calib_value;
  }
  // Radius factor must be between 0 and 1
  if ((!isNaN(r_factor_value)) && (r_factor_value >= 0) && (r_factor_value <= 1)){
    params.r_factor = r_factor_value;
  }
  // No checks currently for the following parameters
  params.pxls_detected_min = pxls_detected_min_value;
  params.residual_cutoff = residual_cutoff_value;
  displayParams();
}



function resetPressureChart(){
	pressureChart.data.datasets[0]["data"] = [];
	pressureChart.update();
}


var pressureChart = new Chart(elem("chart"), {
  type: 'scatter',
  data: {
    datasets: [{
    borderColor: ['rgba(0, 0, 209, 1)'],
    backgroundColor: ['rgba(0, 0, 209, 0.2)'],
    data:
    [{x: 0, y: 0}]
    }]
  },
  options: {
    responsive: true,
    maintainAspectRatio: true,
    aspectRatio: 2,
    animation: false,
    legend: {
    display: false,
    labels: {
      usePointStyle: true,
    },
          position: 'right',
    onClick: (e) => e.stopPropagation()
      },
    title: {
      display: false,
      text: 'Instrument reading',
    position: 'bottom',
    fontSize: 16,
      },
    scales: {
      yAxes: [{
        ticks : {
          min: 0
        },
        scaleLabel: {
          display: true,
          labelString: "Pressure (psig)",
          fontSize: 15,
        }
      }],
      xAxes: [{
        gridLines: {
          display: false
        },
        ticks : {
          min: 0
        },
        scaleLabel: {
          display: true,
          labelString: "Time (s)",
          fontSize: 15,
        }
      }]
    },
  }
  });


// provides shorthand for getting element id
function elem(elem_id){
  return document.getElementById(elem_id);
}

</script>




{% endblock content %}


